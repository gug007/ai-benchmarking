<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>CS: Inline — Counter-Strike inspired, single-file</title>
    <meta name="description" content="A Counter-Strike inspired top-down game in a single HTML file. Elegant UI, modern visuals, and inline CSS/JS only." />
    <style>
      :root {
        --bg-0: #0b0f14;
        --bg-1: #0f1724;
        --bg-2: #0c1220;
        --panel: rgba(255, 255, 255, 0.06);
        --panel-2: rgba(255, 255, 255, 0.08);
        --stroke: rgba(255, 255, 255, 0.12);
        --text: #e8eef8;
        --muted: #9db0c8;
        --accent: #67e8f9;
        --accent-2: #22d3ee;
        --t: #ef4444;
        --ct: #60a5fa;
        --ok: #34d399;
        --warn: #f59e0b;
        --danger: #ef4444;
        --glass-blur: 14px;
        --radius-lg: 18px;
        --radius-md: 14px;
        --radius-sm: 10px;
        --shadow-1: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
        --shadow-2: 0 16px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);
        --ring: 0 0 0 1px var(--stroke), 0 0 0 8px rgba(103,232,249,0.08);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        color: var(--text);
        background:
          radial-gradient(1200px 600px at 15% 20%, rgba(34,211,238,0.08), transparent 60%),
          radial-gradient(1200px 600px at 85% 80%, rgba(99,102,241,0.10), transparent 60%),
          radial-gradient(1000px 500px at 50% -10%, rgba(14,165,233,0.15), transparent 50%),
          linear-gradient(180deg, var(--bg-1), var(--bg-0) 60%);
        font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        overflow: hidden;
      }

      .chrome {
        position: fixed;
        inset: 16px;
        border-radius: var(--radius-lg);
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        border: 1px solid var(--stroke);
        box-shadow: var(--shadow-2);
        overflow: hidden;
      }

      .topbar {
        position: absolute;
        top: 0; left: 0; right: 0;
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        gap: 12px;
        padding: 14px 18px;
        backdrop-filter: blur(var(--glass-blur));
        background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.0));
        border-bottom: 1px solid var(--stroke);
        z-index: 20;
      }
      .brand {
        display: flex; align-items: center; gap: 10px;
        font-weight: 700; letter-spacing: 0.4px;
      }
      .brand .logo {
        width: 28px; height: 28px; border-radius: 8px;
        background: conic-gradient(from 180deg, var(--accent), var(--ct), var(--accent-2), var(--accent));
        box-shadow: 0 4px 20px rgba(34,211,238,0.25);
        position: relative;
      }
      .brand .logo::after {
        content: "";
        position: absolute; inset: 4px;
        border-radius: 6px; background: rgba(0,0,0,0.7);
      }
      .brand span { opacity: 0.9; }

      .score {
        display: inline-grid; grid-auto-flow: column; gap: 10px;
        align-items: center; font-weight: 700; font-variant-numeric: tabular-nums;
      }
      .badge { padding: 6px 10px; border-radius: 999px; backdrop-filter: blur(8px); border: 1px solid var(--stroke); background: var(--panel); box-shadow: var(--shadow-1); }
      .badge.t { color: #fff; background: linear-gradient(180deg, rgba(239,68,68,0.7), rgba(239,68,68,0.2)); border-color: rgba(239,68,68,0.3); }
      .badge.ct { color: #fff; background: linear-gradient(180deg, rgba(96,165,250,0.7), rgba(96,165,250,0.2)); border-color: rgba(96,165,250,0.3); }
      .divider { opacity: 0.3; margin: 0 6px; }

      .timer { justify-self: center; font-weight: 800; letter-spacing: 1px; }
      .round-status { justify-self: end; opacity: 0.9; }

      .stage {
        position: absolute; inset: 0;
        display: grid;
        grid-template-columns: 100%; grid-template-rows: 100%;
      }
      canvas#game {
        width: 100%; height: 100%; display: block;
        background: radial-gradient(1000px 1000px at 50% 50%, rgba(103,232,249,0.06), transparent 60%),
                    radial-gradient(800px 800px at 20% 80%, rgba(99,102,241,0.06), transparent 60%),
                    linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08));
      }

      .hud {
        pointer-events: none;
        position: absolute; inset: 0; z-index: 10;
      }
      .hud .bottom-center {
        position: absolute; left: 50%; bottom: 26px; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 10px;
      }
      .ammo {
        display: flex; align-items: baseline; gap: 8px; font-variant-numeric: tabular-nums;
        padding: 10px 14px; border-radius: 12px; background: var(--panel);
        border: 1px solid var(--stroke); backdrop-filter: blur(var(--glass-blur)); box-shadow: var(--shadow-1);
      }
      .ammo .weapon { font-weight: 700; opacity: 0.9; }
      .ammo .clip { font-size: 22px; font-weight: 800; }
      .ammo .reserve { opacity: 0.7; }

      .crosshair { position: absolute; left: 50%; top: 50%; width: 28px; height: 28px; transform: translate(-50%, -50%); pointer-events: none; opacity: 0.9; }
      .crosshair::before, .crosshair::after { content: ""; position: absolute; inset: 0; border-radius: 999px; }
      .crosshair::before { border: 2px solid rgba(255,255,255,0.22); box-shadow: inset 0 0 0 2px rgba(103,232,249,0.15); }
      .crosshair::after { border: 2px solid rgba(103,232,249,0.5); mask: radial-gradient(closest-side, transparent calc(50% - 2px), black calc(50% - 1px)); }

      .minimap {
        position: absolute; right: 24px; top: 80px; width: 200px; height: 200px;
        border-radius: var(--radius-md); background: var(--panel);
        border: 1px solid var(--stroke); box-shadow: var(--shadow-1); backdrop-filter: blur(var(--glass-blur));
        overflow: hidden;
      }
      .minimap canvas { width: 100%; height: 100%; display: block; }

      .banner {
        position: absolute; top: 64px; left: 50%; transform: translateX(-50%);
        padding: 10px 16px; border-radius: 999px; background: var(--panel-2);
        border: 1px solid var(--stroke); box-shadow: var(--shadow-1); backdrop-filter: blur(var(--glass-blur));
        font-weight: 700; letter-spacing: 0.5px; opacity: 0; transition: opacity .3s ease, transform .3s ease;
      }
      .banner.show { opacity: 1; transform: translateX(-50%) translateY(0); }

      .menu {
        position: absolute; inset: 0; display: grid; place-items: center; z-index: 30;
        background: radial-gradient(1000px 800px at 50% 50%, rgba(14,165,233,0.15), rgba(99,102,241,0.06) 60%, rgba(0,0,0,0.65));
        backdrop-filter: blur(10px);
      }
      .menu-panel {
        width: min(860px, 92vw);
        border-radius: var(--radius-lg); border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        box-shadow: var(--shadow-2); padding: 22px; display: grid; gap: 18px;
      }
      .menu-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .title { display: flex; align-items: center; gap: 12px; }
      .title .logo { width: 40px; height: 40px; border-radius: 10px; background: conic-gradient(from 180deg, var(--accent), var(--ct), var(--accent-2), var(--accent)); box-shadow: 0 8px 30px rgba(34,211,238,0.25); position: relative; }
      .title .logo::after { content: ""; position: absolute; inset: 6px; border-radius: 8px; background: rgba(0,0,0,0.75); }
      .title h1 { margin: 0; font-size: 24px; letter-spacing: 0.4px; }
      .subtitle { margin: 0; opacity: 0.7; }
      .menu-grid { display: grid; grid-template-columns: 2fr 1.4fr; gap: 18px; }
      .panel { border-radius: var(--radius-md); background: var(--panel); border: 1px solid var(--stroke); padding: 16px; box-shadow: var(--shadow-1); }
      .panel h3 { margin: 0 0 12px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 0.12em; opacity: 0.8; }
      .btn-row { display: flex; gap: 10px; flex-wrap: wrap; }
      .btn {
        appearance: none; border: 1px solid var(--stroke); color: var(--text);
        background: linear-gradient(180deg, rgba(103,232,249,0.16), rgba(103,232,249,0.04));
        padding: 10px 14px; border-radius: 12px; font-weight: 700; letter-spacing: 0.3px;
        transition: transform .12s ease, box-shadow .2s ease, background .2s ease;
        box-shadow: var(--shadow-1); cursor: pointer;
      }
      .btn:hover { transform: translateY(-1px); box-shadow: 0 12px 32px rgba(103,232,249,0.15), var(--shadow-1); }
      .btn.primary { background: linear-gradient(180deg, rgba(34,211,238,0.5), rgba(34,211,238,0.12)); border-color: rgba(34,211,238,0.45); }
      .btn.ghost { background: var(--panel); }
      .control { display: grid; gap: 10px; }
      .range { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
      input[type="range"] { width: 100%; accent-color: var(--accent-2); }
      .kbd { padding: 2px 8px; border: 1px solid var(--stroke); border-radius: 8px; background: var(--panel); box-shadow: inset 0 -1px 0 rgba(255,255,255,0.05); font-variant: tabular-nums; }

      .scoreboard {
        position: absolute; inset: 0; display: grid; place-items: center; z-index: 25; pointer-events: none; opacity: 0; transition: opacity .15s ease;
        background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.0));
      }
      .scoreboard.show { opacity: 1; }
      .scoreboard .sheet { pointer-events: all; width: min(840px, 92vw); border-radius: var(--radius-lg); border: 1px solid var(--stroke); background: var(--panel); backdrop-filter: blur(var(--glass-blur)); box-shadow: var(--shadow-2); overflow: hidden; }
      .scoreboard table { width: 100%; border-collapse: collapse; font-variant-numeric: tabular-nums; }
      .scoreboard th, .scoreboard td { padding: 12px 14px; border-bottom: 1px solid var(--stroke); text-align: left; }
      .scoreboard thead th { font-size: 12px; text-transform: uppercase; letter-spacing: 0.12em; opacity: 0.75; }
      .scoreboard tbody tr:hover { background: rgba(255,255,255,0.04); }
      .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--stroke); background: var(--panel); }
      .pill.t { border-color: rgba(239,68,68,0.35); background: linear-gradient(180deg, rgba(239,68,68,0.25), rgba(239,68,68,0.12)); }
      .pill.ct { border-color: rgba(96,165,250,0.35); background: linear-gradient(180deg, rgba(96,165,250,0.25), rgba(96,165,250,0.12)); }

      .tooltip { position: absolute; bottom: 20px; left: 20px; opacity: 0.8; background: var(--panel); border: 1px solid var(--stroke); border-radius: 10px; padding: 10px 12px; box-shadow: var(--shadow-1); }
      .tooltip kbd { font-weight: 700; padding: 2px 8px; border-radius: 6px; background: rgba(255,255,255,0.07); border: 1px solid var(--stroke); }

      @media (max-width: 900px) {
        .minimap { width: 160px; height: 160px; right: 16px; top: 92px; }
        .ammo { padding: 8px 12px; }
        .menu-grid { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="chrome">
      <div class="topbar">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <span>CS: Inline</span>
        </div>
        <div class="timer" id="ui-timer">01:45</div>
        <div class="round-status" id="ui-round">Buy Phase</div>
      </div>

      <div class="stage">
        <canvas id="game"></canvas>

        <div class="hud" aria-hidden="true">
          <div class="banner" id="ui-banner">Round Start</div>
          <div class="minimap"><canvas id="minimap"></canvas></div>
          <div class="bottom-center">
            <div class="ammo">
              <div class="weapon" id="ui-weapon">Pistol</div>
              <div class="clip" id="ui-clip">12</div>
              <div class="reserve" id="ui-reserve">/ 48</div>
            </div>
            <div class="score">
              <span class="badge ct">CT <span id="ui-ct">0</span></span>
              <span class="divider">—</span>
              <span class="badge t">T <span id="ui-t">0</span></span>
            </div>
          </div>
          <div class="crosshair"></div>
        </div>

        <div class="scoreboard" id="scoreboard">
          <div class="sheet">
            <table>
              <thead>
                <tr>
                  <th>Player</th>
                  <th>Team</th>
                  <th>K</th>
                  <th>D</th>
                  <th>Score</th>
                </tr>
              </thead>
              <tbody id="score-rows"></tbody>
            </table>
          </div>
        </div>

        <div class="tooltip" id="tooltip">
          <div><kbd>WASD</kbd> move • <kbd>Mouse</kbd> aim • <kbd>Click</kbd> shoot</div>
          <div><kbd>E</kbd> interact • <kbd>R</kbd> reload • <kbd>B</kbd> buy • <kbd>Tab</kbd> scores</div>
          <div><kbd>Esc</kbd> pause</div>
        </div>

        <div class="menu" id="menu">
          <div class="menu-panel">
            <div class="menu-header">
              <div class="title">
                <div class="logo" aria-hidden="true"></div>
                <div>
                  <h1>CS: Inline</h1>
                  <p class="subtitle">Counter‑Strike inspired. Single file. Beautifully crafted.</p>
                </div>
              </div>
              <div class="btn-row">
                <button class="btn ghost" id="btn-how">How to Play</button>
                <button class="btn primary" id="btn-start">Start Match</button>
              </div>
            </div>
            <div class="menu-grid">
              <div class="panel">
                <h3>Match Setup</h3>
                <div class="btn-row">
                  <button class="btn" data-difficulty="easy">Easy</button>
                  <button class="btn" data-difficulty="normal">Normal</button>
                  <button class="btn" data-difficulty="hard">Hard</button>
                </div>
                <div class="btn-row" style="margin-top:12px">
                  <button class="btn" data-rounds="8">First to 8</button>
                  <button class="btn" data-rounds="12">First to 12</button>
                  <button class="btn" data-rounds="16">First to 16</button>
                </div>
              </div>
              <div class="panel">
                <h3>Settings</h3>
                <div class="control">
                  <div class="range"><label for="sensitivity">Mouse sensitivity</label><span class="kbd" id="sensLabel">1.00</span></div>
                  <input id="sensitivity" type="range" min="0.5" max="2.0" step="0.01" value="1.00" />
                </div>
                <div class="control" style="margin-top:12px">
                  <div class="range"><label for="volume">Master volume</label><span class="kbd" id="volLabel">0.70</span></div>
                  <input id="volume" type="range" min="0" max="1" step="0.01" value="0.70" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      ;(() => {
        "use strict";

        // ---------- Utilities ----------
        const TAU = Math.PI * 2;
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const now = () => performance.now();
        const rand = (a, b) => a + Math.random() * (b - a);

        function mixColor(c1, c2, t) {
          const a = [
            parseInt(c1.slice(1,3),16),
            parseInt(c1.slice(3,5),16),
            parseInt(c1.slice(5,7),16)
          ];
          const b = [
            parseInt(c2.slice(1,3),16),
            parseInt(c2.slice(3,5),16),
            parseInt(c2.slice(5,7),16)
          ];
          const m = (i) => Math.round(lerp(a[i], b[i], t)).toString(16).padStart(2, '0');
          return `#${m(0)}${m(1)}${m(2)}`;
        }

        function length(x, y) { return Math.hypot(x, y); }
        function normalize(x, y) {
          const d = Math.hypot(x, y) || 1;
          return [x / d, y / d];
        }

        function rotate(x, y, a) {
          const c = Math.cos(a), s = Math.sin(a);
          return [x * c - y * s, x * s + y * c];
        }

        function pointInRect(px, py, r) {
          return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
        }

        function segmentIntersectsAABB(p, q, r) {
          // Liang–Barsky style clip for AABB
          let t0 = 0, t1 = 1;
          const dx = q.x - p.x, dy = q.y - p.y;
          const pVals = [-dx, dx, -dy, dy];
          const qVals = [p.x - r.x, r.x + r.w - p.x, p.y - r.y, r.y + r.h - p.y];
          for (let i = 0; i < 4; i++) {
            const P = pVals[i], Q = qVals[i];
            if (P === 0) { if (Q < 0) return false; }
            else {
              const t = Q / P;
              if (P < 0) { if (t > t1) return false; if (t > t0) t0 = t; }
              else { if (t < t0) return false; if (t < t1) t1 = t; }
            }
          }
          return true;
        }

        function segmentIntersectsCircle(p, q, c, r) {
          const d = { x: q.x - p.x, y: q.y - p.y };
          const f = { x: p.x - c.x, y: p.y - c.y };
          const a = d.x * d.x + d.y * d.y;
          const b = 2 * (f.x * d.x + f.y * d.y);
          const cc = f.x * f.x + f.y * f.y - r * r;
          let disc = b * b - 4 * a * cc;
          if (disc < 0) return false;
          disc = Math.sqrt(disc);
          const t1 = (-b - disc) / (2 * a);
          const t2 = (-b + disc) / (2 * a);
          if (t1 >= 0 && t1 <= 1) return true;
          if (t2 >= 0 && t2 <= 1) return true;
          return false;
        }

        function randChoice(arr) { return arr[(Math.random() * arr.length) | 0]; }

        // ---------- Audio ----------
        const Audio = (() => {
          let ctx = null;
          let master = null;
          let volume = 0.7;
          const ensure = () => {
            if (!ctx) {
              ctx = new (window.AudioContext || window.webkitAudioContext)();
              master = ctx.createGain(); master.gain.value = volume; master.connect(ctx.destination);
            }
          };
          const setVolume = (v) => { volume = v; if (master) master.gain.value = v; };

          function beep(freq, dur = 0.08, type = 'sine', gain = 0.6) {
            ensure();
            const o = ctx.createOscillator(); o.type = type; o.frequency.value = freq;
            const g = ctx.createGain(); g.gain.value = gain;
            o.connect(g).connect(master);
            const t = ctx.currentTime;
            g.gain.setValueAtTime(gain, t);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
            o.start();
            o.stop(t + dur);
          }

          function clickyShot() {
            ensure();
            // Short noise burst + highpass
            const bufferSize = 2048;
            const noise = ctx.createScriptProcessor(bufferSize, 1, 1);
            const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 800;
            const g = ctx.createGain(); g.gain.value = 0.6;
            noise.onaudioprocess = (e) => {
              const out = e.outputBuffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) out[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            };
            noise.connect(hp).connect(g).connect(master);
            setTimeout(() => noise.disconnect(), 16);
            beep(rand(200, 400), 0.03, 'square', 0.15);
          }

          const ui = {
            start: () => beep(640, 0.12, 'triangle', 0.4),
            confirm: () => beep(840, 0.08, 'triangle', 0.35),
            warn: () => { beep(280, 0.08, 'square', 0.4); setTimeout(() => beep(220, 0.08, 'square', 0.35), 90); },
          };

          const game = {
            shot: () => clickyShot(),
            hit: () => beep(220, 0.04, 'sine', 0.2),
            plantTick: () => beep(720, 0.03, 'square', 0.12),
            defuseTick: () => beep(520, 0.03, 'sine', 0.12),
            round: () => { beep(420, 0.12, 'triangle', 0.35); setTimeout(() => beep(620, 0.12, 'triangle', 0.25), 120); },
            success: () => { beep(680, 0.09, 'triangle', 0.35); setTimeout(() => beep(880, 0.09, 'triangle', 0.32), 95); },
            fail: () => { beep(260, 0.10, 'square', 0.35); setTimeout(() => beep(180, 0.10, 'square', 0.32), 110); },
          };

          return { ensure, setVolume, ui, game };
        })();

        // ---------- Canvas & Minimap ----------
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        function resize() {
          const { clientWidth: w, clientHeight: h } = canvas;
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
        }
        new ResizeObserver(resize).observe(canvas);

        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        function resizeMinimap() {
          const { clientWidth: w, clientHeight: h } = minimapCanvas;
          minimapCanvas.width = Math.floor(w * dpr);
          minimapCanvas.height = Math.floor(h * dpr);
        }
        new ResizeObserver(resizeMinimap).observe(minimapCanvas);

        // ---------- UI Elements ----------
        const ui = {
          timer: document.getElementById('ui-timer'),
          round: document.getElementById('ui-round'),
          weapon: document.getElementById('ui-weapon'),
          clip: document.getElementById('ui-clip'),
          reserve: document.getElementById('ui-reserve'),
          ct: document.getElementById('ui-ct'),
          t: document.getElementById('ui-t'),
          scoreboard: document.getElementById('scoreboard'),
          scoreRows: document.getElementById('score-rows'),
          banner: document.getElementById('ui-banner'),
          menu: document.getElementById('menu'),
          btnStart: document.getElementById('btn-start'),
          btnHow: document.getElementById('btn-how'),
          sensitivity: document.getElementById('sensitivity'),
          volume: document.getElementById('volume'),
          sensLabel: document.getElementById('sensLabel'),
          volLabel: document.getElementById('volLabel'),
        };

        const matchConfig = { targetRounds: 8, difficulty: 'normal' };
        document.querySelectorAll('[data-rounds]').forEach(b => b.addEventListener('click', () => {
          matchConfig.targetRounds = parseInt(b.getAttribute('data-rounds'), 10) || 8;
          Audio.ui.confirm();
        }));
        document.querySelectorAll('[data-difficulty]').forEach(b => b.addEventListener('click', () => {
          matchConfig.difficulty = b.getAttribute('data-difficulty') || 'normal';
          Audio.ui.confirm();
        }));

        ui.sensitivity.addEventListener('input', () => {
          Settings.mouseSensitivity = parseFloat(ui.sensitivity.value);
          ui.sensLabel.textContent = Settings.mouseSensitivity.toFixed(2);
        });
        ui.volume.addEventListener('input', () => {
          Settings.masterVolume = parseFloat(ui.volume.value);
          ui.volLabel.textContent = Settings.masterVolume.toFixed(2);
          Audio.setVolume(Settings.masterVolume);
        });

        const Settings = {
          mouseSensitivity: parseFloat(ui.sensitivity.value),
          masterVolume: parseFloat(ui.volume.value),
        };
        Audio.setVolume(Settings.masterVolume);

        // ---------- Input ----------
        const input = {
          up: false, down: false, left: false, right: false,
          reload: false, interact: false, buy: false, pause: false, scores: false,
          mouseX: 0, mouseY: 0, mouseDown: false,
        };
        const pressed = new Set();
        window.addEventListener('keydown', (e) => {
          if (e.repeat) return;
          pressed.add(e.key.toLowerCase());
          switch (e.key.toLowerCase()) {
            case 'w': input.up = true; break;
            case 's': input.down = true; break;
            case 'a': input.left = true; break;
            case 'd': input.right = true; break;
            case 'r': input.reload = true; break;
            case 'e': input.interact = true; break;
            case 'b': input.buy = true; break;
            case 'escape': input.pause = true; break;
            case 'tab': input.scores = true; e.preventDefault(); break;
          }
        });
        window.addEventListener('keyup', (e) => {
          pressed.delete(e.key.toLowerCase());
          switch (e.key.toLowerCase()) {
            case 'w': input.up = false; break;
            case 's': input.down = false; break;
            case 'a': input.left = false; break;
            case 'd': input.right = false; break;
            case 'r': input.reload = false; break;
            case 'e': input.interact = false; break;
            case 'b': input.buy = false; break;
            case 'escape': input.pause = false; break;
            case 'tab': input.scores = false; e.preventDefault(); break;
          }
        });
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          input.mouseX = (e.clientX - rect.left) * dpr;
          input.mouseY = (e.clientY - rect.top) * dpr;
        });
        canvas.addEventListener('mousedown', () => { input.mouseDown = true; });
        window.addEventListener('mouseup', () => { input.mouseDown = false; });

        // ---------- Map & World ----------
        const map = {
          width: 2400,
          height: 1600,
          walls: [],
          sites: { A: { x: 360, y: 320, w: 360, h: 360 }, B: { x: 1680, y: 920, w: 400, h: 360 } },
          spawns: {
            T: [ {x: 300, y: 1200}, {x: 420, y: 1180}, {x: 520, y: 1150} ],
            CT: [ {x: 1900, y: 300}, {x: 1800, y: 340}, {x: 2000, y: 280} ]
          }
        };

        function buildMap() {
          const W = map.walls;
          W.length = 0;
          const add = (x,y,w,h) => W.push({ x, y, w, h });
          // Perimeter
          add(-40, -40, map.width + 80, 40);
          add(-40, map.height, map.width + 80, 40);
          add(-40, 0, 40, map.height);
          add(map.width, 0, 40, map.height);
          // Central structures and corridors
          add(800, 0, 40, 540);
          add(800, 700, 40, 900);
          add(560, 540, 280, 40);
          add(840, 540, 320, 40);
          add(1160, 260, 40, 600);
          add(1160, 1000, 40, 360);
          add(1280, 1000, 360, 40);
          add(1600, 1000, 40, 380);
          add(1560, 720, 40, 280);
          add(1200, 720, 360, 40);
          // A site surroundings
          add(260, 240, 40, 560);
          add(260, 240, 520, 40);
          add(780, 240, 40, 240);
          // B site surroundings
          add(1600, 840, 560, 40);
          add(1600, 840, 40, 520);
          add(1600, 1260, 560, 40);
          // Boxes
          add(980, 400, 80, 80);
          add(1000, 1080, 120, 120);
          add(1420, 1130, 120, 80);
          add(440, 980, 100, 100);
        }
        buildMap();

        // ---------- Entities ----------
        const TEAM = { T: 'T', CT: 'CT' };

        class Weapon {
          constructor(opts) {
            this.name = opts.name;
            this.damage = opts.damage;
            this.fireRateMs = opts.fireRateMs; // min ms between shots
            this.spread = opts.spread; // radians
            this.range = opts.range;
            this.magSize = opts.magSize;
            this.reserve = opts.reserve;
            this.reloadMs = opts.reloadMs;
            this.auto = !!opts.auto;
            this.lastShotAt = -1;
            this.clip = this.magSize;
            this.reloading = false;
            this.reloadEndAt = 0;
          }
        }

        const Weapons = {
          PISTOL: () => new Weapon({ name: 'Pistol', damage: 22, fireRateMs: 220, spread: 0.04, range: 1200, magSize: 12, reserve: 48, reloadMs: 1000, auto: false }),
          RIFLE: () => new Weapon({ name: 'Rifle', damage: 30, fireRateMs: 90, spread: 0.03, range: 1400, magSize: 30, reserve: 90, reloadMs: 1400, auto: true }),
          SMG: () => new Weapon({ name: 'SMG', damage: 18, fireRateMs: 70, spread: 0.055, range: 1100, magSize: 30, reserve: 120, reloadMs: 1250, auto: true }),
        };

        class Entity {
          constructor(x, y, team) {
            this.x = x; this.y = y; this.r = 16;
            this.team = team;
            this.health = 100;
            this.alive = true;
            this.kills = 0; this.deaths = 0; this.score = 0;
          }
        }

        class Player extends Entity {
          constructor(x, y, team, isBot = false, name = '') {
            super(x, y, team);
            this.isBot = isBot;
            this.name = name || (isBot ? (team === TEAM.CT ? 'CT Bot' : 'T Bot') : 'You');
            this.speed = 2.1; // px per ms at dpr scale
            this.aim = 0; // radians
            this.weapon = Weapons.PISTOL();
            this.reloadHeld = false;
            this.holdProgress = 0; // interact progress
            // AI fields
            this.ai = { target: null, nextThinkAt: 0, state: 'patrol', memory: { lastSeenEnemyAt: 0, lastSeenPos: {x:0,y:0} } };
          }
        }

        class ShotTrace {
          constructor(x1, y1, x2, y2) {
            this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
            this.alpha = 1; this.spawn = now();
          }
        }

        const game = {
          state: 'menu', // 'menu' | 'live' | 'paused'
          round: 'buy', // 'buy' | 'live' | 'planted' | 'end'
          roundTime: 105000, // 1:45 in ms
          buyTime: 15000,
          plantedTime: 40000,
          defuseTime: 7000,
          timeLeftMs: 105000,
          plantedAt: 0,
          winner: null, // TEAM.T | TEAM.CT
          score: { T: 0, CT: 0 },
          players: [],
          human: null,
          carrier: null, // bomb carrier (Player)
          bomb: { planted: false, x: 0, y: 0, defusing: null, defuseProgress: 0, plantProgress: 0 },
          shots: [],
          lastUpdate: now(),
          camera: { x: 0, y: 0, zoom: 1 },
        };

        function resetRound(initial = false) {
          // Place players
          const side = TEAM;
          const Ts = game.players.filter(p => p.team === side.T);
          const CTs = game.players.filter(p => p.team === side.CT);
          Ts.forEach((p, i) => { const s = map.spawns.T[i % map.spawns.T.length]; p.x = s.x; p.y = s.y; p.health = 100; p.alive = true; p.weapon = Weapons.PISTOL(); });
          CTs.forEach((p, i) => { const s = map.spawns.CT[i % map.spawns.CT.length]; p.x = s.x; p.y = s.y; p.health = 100; p.alive = true; p.weapon = Weapons.PISTOL(); });
          // Assign bomb to a random T
          game.carrier = randChoice(Ts);
          game.bomb = { planted: false, x: 0, y: 0, defusing: null, defuseProgress: 0, plantProgress: 0 };
          game.round = 'buy';
          game.timeLeftMs = game.roundTime;
          game.winner = null;
          if (!initial) showBanner('New Round');
          Audio.game.round();
        }

        function showBanner(text) {
          ui.banner.textContent = text;
          ui.banner.classList.add('show');
          setTimeout(() => ui.banner.classList.remove('show'), 1200);
        }

        function initPlayers() {
          const human = new Player(map.spawns.CT[0].x, map.spawns.CT[0].y, TEAM.CT, false, 'You');
          human.weapon = Weapons.PISTOL();
          const bots = [
            new Player(map.spawns.CT[1].x, map.spawns.CT[1].y, TEAM.CT, true, 'CT Nova'),
            new Player(map.spawns.T[0].x, map.spawns.T[0].y, TEAM.T, true, 'T Echo'),
            new Player(map.spawns.T[1].x, map.spawns.T[1].y, TEAM.T, true, 'T Viper'),
          ];
          game.players = [human, ...bots];
          game.human = human;
          resetRound(true);
        }

        // ---------- Physics ----------
        function moveEntity(e, dx, dy) {
          if (!e.alive) return;
          // Try X
          e.x += dx;
          for (const w of map.walls) {
            if (circleRectIntersect(e, w)) {
              if (dx > 0) e.x = w.x - e.r; else e.x = w.x + w.w + e.r;
            }
          }
          // Try Y
          e.y += dy;
          for (const w of map.walls) {
            if (circleRectIntersect(e, w)) {
              if (dy > 0) e.y = w.y - e.r; else e.y = w.y + w.h + e.r;
            }
          }
        }

        function circleRectIntersect(c, r) {
          const nx = clamp(c.x, r.x, r.x + r.w);
          const ny = clamp(c.y, r.y, r.y + r.h);
          const dx = c.x - nx, dy = c.y - ny;
          return (dx * dx + dy * dy) <= (c.r * c.r);
        }

        function hasLineOfSight(a, b) {
          const p = { x: a.x, y: a.y };
          const q = { x: b.x, y: b.y };
          for (const w of map.walls) if (segmentIntersectsAABB(p, q, w)) return false;
          return true;
        }

        // ---------- Combat ----------
        function fireWeapon(shooter) {
          if (!shooter.alive) return;
          const w = shooter.weapon;
          const t = now();
          if (w.reloading) return;
          if (t - w.lastShotAt < w.fireRateMs) return;
          if (w.clip <= 0) { reloadWeapon(shooter); return; }

          // shoot
          w.lastShotAt = t;
          w.clip -= 1;
          Audio.game.shot();

          const spread = w.spread * (shooter.isBot ? (matchConfig.difficulty === 'hard' ? 0.6 : matchConfig.difficulty === 'normal' ? 0.8 : 1.0) : 1.0);
          const angle = shooter.aim + rand(-spread, spread);
          const dir = { x: Math.cos(angle), y: Math.sin(angle) };
          const muzzle = { x: shooter.x + dir.x * (shooter.r + 6), y: shooter.y + dir.y * (shooter.r + 6) };
          const end = { x: muzzle.x + dir.x * w.range, y: muzzle.y + dir.y * w.range };

          // collide with walls
          let hitPoint = { ...end };
          for (const wall of map.walls) {
            if (segmentIntersectsAABB(muzzle, end, wall)) {
              // approximate: clamp end to wall edge by stepping toward
              const steps = 20;
              let px = end.x, py = end.y;
              for (let s = 0; s < steps; s++) {
                const lx = lerp(end.x, muzzle.x, s / steps);
                const ly = lerp(end.y, muzzle.y, s / steps);
                if (pointInRect(lx, ly, wall)) { hitPoint = { x: px, y: py }; break; }
                px = lx; py = ly;
              }
            }
          }

          // collide with players
          let victim = null;
          let closestDist = Infinity;
          for (const p of game.players) {
            if (p === shooter || !p.alive) continue;
            if (p.team === shooter.team) continue;
            if (segmentIntersectsCircle(muzzle, hitPoint, { x: p.x, y: p.y }, p.r)) {
              const d = Math.hypot(p.x - shooter.x, p.y - shooter.y);
              if (d < closestDist) { closestDist = d; victim = p; }
            }
          }
          if (victim) {
            victim.health -= w.damage;
            Audio.game.hit();
            hitPoint = { x: victim.x, y: victim.y };
            if (victim.health <= 0) {
              victim.alive = false; victim.deaths += 1;
              shooter.kills += 1; shooter.score += 1;
              if (victim === game.carrier && !game.bomb.planted) {
                game.carrier = null; // drop bomb at victim pos (implicitly)
                game.bomb.x = victim.x; game.bomb.y = victim.y;
              }
              checkRoundEndElimination();
            }
          }

          game.shots.push(new ShotTrace(muzzle.x, muzzle.y, hitPoint.x, hitPoint.y));
        }

        function reloadWeapon(p) {
          const w = p.weapon;
          if (w.reloading || w.clip === w.magSize || w.reserve <= 0) return;
          w.reloading = true; w.reloadEndAt = now() + w.reloadMs;
        }

        function completeReload(w) {
          const needed = w.magSize - w.clip;
          const take = Math.min(needed, w.reserve);
          w.clip += take; w.reserve -= take; w.reloading = false;
        }

        function checkRoundEndElimination() {
          const TsAlive = game.players.some(p => p.team === TEAM.T && p.alive);
          const CTsAlive = game.players.some(p => p.team === TEAM.CT && p.alive);
          if (!TsAlive) endRound(TEAM.CT, 'All terrorists eliminated');
          else if (!CTsAlive) endRound(TEAM.T, 'All counter-terrorists eliminated');
        }

        function endRound(winner, reason) {
          if (game.round === 'end') return;
          game.round = 'end';
          game.winner = winner;
          game.score[winner] += 1;
          ui.ct.textContent = game.score.CT;
          ui.t.textContent = game.score.T;
          ui.round.textContent = `${winner} win`;
          showBanner(`${winner} win — ${reason}`);
          (winner === TEAM.CT ? Audio.game.success : Audio.game.fail)();
          setTimeout(() => { resetRound(); }, 2200);
        }

        // ---------- Bomb Logic ----------
        function updateBomb(dt) {
          if (!game.bomb.planted) {
            // Plant if carrier exists, is T, inside site, and interacting
            if (game.carrier && game.carrier.alive && game.carrier.team === TEAM.T) {
              const insideA = pointInRect(game.carrier.x, game.carrier.y, map.sites.A);
              const insideB = pointInRect(game.carrier.x, game.carrier.y, map.sites.B);
              const inSite = insideA || insideB;
              if (inSite && (game.carrier.isBot || (game.human === game.carrier && input.interact))) {
                game.bomb.plantProgress += dt;
                if (Math.floor(game.bomb.plantProgress / 300) !== Math.floor((game.bomb.plantProgress - dt) / 300)) Audio.game.plantTick();
                if (game.bomb.plantProgress >= 3000) {
                  game.bomb.planted = true; game.bomb.x = game.carrier.x; game.bomb.y = game.carrier.y; game.plantedAt = now(); game.round = 'planted';
                  showBanner('Bomb planted');
                  Audio.game.round();
                }
              } else {
                game.bomb.plantProgress = 0;
              }
            } else {
              // bomb on ground — allow pickup by T
              for (const p of game.players) {
                if (p.team !== TEAM.T || !p.alive) continue;
                const d = Math.hypot(p.x - game.bomb.x, p.y - game.bomb.y);
                if (d < p.r + 14) { game.carrier = p; break; }
              }
            }
          } else {
            // Bomb ticking
            const elapsed = now() - game.plantedAt;
            game.timeLeftMs = Math.max(0, game.plantedTime - elapsed);
            if (game.timeLeftMs <= 0) { endRound(TEAM.T, 'Bomb exploded'); return; }
            // Defuse
            const defuser = game.players.find(p => p.team === TEAM.CT && p.alive && Math.hypot(p.x - game.bomb.x, p.y - game.bomb.y) < p.r + 20 && (p.isBot || (p === game.human && input.interact)));
            if (defuser) {
              game.bomb.defusing = defuser;
              game.bomb.defuseProgress += dt;
              if (Math.floor(game.bomb.defuseProgress / 350) !== Math.floor((game.bomb.defuseProgress - dt) / 350)) Audio.game.defuseTick();
              if (game.bomb.defuseProgress >= game.defuseTime) { endRound(TEAM.CT, 'Bomb defused'); return; }
            } else {
              game.bomb.defusing = null; game.bomb.defuseProgress = Math.max(0, game.bomb.defuseProgress - dt * 0.4);
            }
          }
        }

        // ---------- AI ----------
        function aiThink(p, dt) {
          if (!p.isBot || !p.alive) return;
          const t = now();
          if (t < p.ai.nextThinkAt) return;
          p.ai.nextThinkAt = t + rand(90, 160) * (matchConfig.difficulty === 'hard' ? 0.75 : matchConfig.difficulty === 'easy' ? 1.2 : 1.0);

          // target: closest visible enemy
          let target = null, closest = Infinity;
          for (const other of game.players) {
            if (other === p || !other.alive || other.team === p.team) continue;
            const d = Math.hypot(other.x - p.x, other.y - p.y);
            if (d < closest && hasLineOfSight(p, other)) { closest = d; target = other; }
          }
          p.ai.target = target;
          if (target) { p.ai.memory.lastSeenEnemyAt = t; p.ai.memory.lastSeenPos = { x: target.x, y: target.y }; }

          if (game.round === 'buy') {
            // sometimes upgrade weapon
            if (Math.random() < 0.3) p.weapon = matchConfig.difficulty === 'easy' ? Weapons.SMG() : Weapons.RIFLE();
          }

          // Behavior when carrying bomb
          const isCarrier = (p === game.carrier && !game.bomb.planted);
          const site = Math.random() < 0.5 ? map.sites.A : map.sites.B;
          p.ai.state = isCarrier ? 'toSite' : (target ? 'engage' : 'patrol');

          if (p.ai.state === 'toSite') {
            p.goal = { x: site.x + site.w * 0.5, y: site.y + site.h * 0.5 };
          } else if (p.ai.state === 'engage') {
            p.goal = { x: target.x, y: target.y };
          } else if (p.ai.state === 'patrol') {
            if (!p.goal || Math.hypot(p.goal.x - p.x, p.goal.y - p.y) < 40) {
              p.goal = { x: rand(200, map.width - 200), y: rand(200, map.height - 200) };
            }
          }

          // Aim adjustment
          if (p.ai.target) {
            const ang = Math.atan2(p.ai.target.y - p.y, p.ai.target.x - p.x);
            const turnRate = 0.18; // rad per think
            const diff = ((ang - p.aim + Math.PI) % TAU) - Math.PI;
            p.aim += clamp(diff, -turnRate, turnRate);
          } else if (p.goal) {
            const ang = Math.atan2(p.goal.y - p.y, p.goal.x - p.x);
            p.aim = ang;
          }

          // Shoot if aligned and visible
          if (p.ai.target && hasLineOfSight(p, p.ai.target)) {
            if (Math.random() < (matchConfig.difficulty === 'hard' ? 0.85 : matchConfig.difficulty === 'normal' ? 0.65 : 0.45)) fireWeapon(p);
          }

          // Reload logic
          if (p.weapon.clip === 0 && p.weapon.reserve > 0 && !p.weapon.reloading) reloadWeapon(p);
        }

        function aiMove(p, dt) {
          if (!p.isBot || !p.alive) return;
          const speed = p.speed * (matchConfig.difficulty === 'hard' ? 1.12 : 1.0);
          if (!p.goal) return;
          const vx = p.goal.x - p.x, vy = p.goal.y - p.y;
          const [nx, ny] = normalize(vx, vy);
          moveEntity(p, nx * speed * dt, ny * speed * dt);
        }

        // ---------- Game Loop ----------
        function update(dt) {
          // State transitions
          if (game.round === 'buy') {
            game.timeLeftMs -= dt;
            if (game.timeLeftMs <= game.roundTime - game.buyTime) { game.round = 'live'; ui.round.textContent = 'Live'; showBanner('Live'); }
          } else if (game.round === 'live') {
            game.timeLeftMs -= dt;
            if (game.timeLeftMs <= 0) { endRound(TEAM.CT, 'Time expired'); return; }
          } else if (game.round === 'planted') {
            // handled in updateBomb setting timeLeftMs
          }

          // Input handling human
          const h = game.human;
          if (h && h.alive) {
            // aim at mouse
            h.aim = Math.atan2(input.mouseY - (h.y - game.camera.y), input.mouseX - (h.x - game.camera.x));
            const mv = { x: (input.right?1:0) - (input.left?1:0), y: (input.down?1:0) - (input.up?1:0) };
            const [mx, my] = normalize(mv.x, mv.y);
            moveEntity(h, mx * h.speed * dt, my * h.speed * dt);
            // fire
            if (input.mouseDown) fireWeapon(h);
            // reload
            if (input.reload) { reloadWeapon(h); input.reload = false; }
          }

          // Reload completes
          for (const p of game.players) {
            const w = p.weapon;
            if (w.reloading && now() >= w.reloadEndAt) completeReload(w);
          }

          // AI
          for (const p of game.players) aiThink(p, dt);
          for (const p of game.players) aiMove(p, dt);

          // Bomb
          updateBomb(dt);

          // Shots fade
          for (let i = game.shots.length - 1; i >= 0; i--) {
            const s = game.shots[i];
            const age = now() - s.spawn;
            s.alpha = 1 - age / 160;
            if (age > 160) game.shots.splice(i, 1);
          }

          // Camera track human
          if (h) {
            const pad = 360;
            game.camera.x = clamp(h.x - canvas.width * 0.5, -pad, map.width + pad - canvas.width);
            game.camera.y = clamp(h.y - canvas.height * 0.5, -pad, map.height + pad - canvas.height);
          }
        }

        function drawBackground() {
          ctx.save();
          ctx.fillStyle = '#0a0f19';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Map base
          ctx.translate(-game.camera.x, -game.camera.y);
          const grd = ctx.createLinearGradient(0, 0, map.width, map.height);
          grd.addColorStop(0, 'rgba(34,211,238,0.06)');
          grd.addColorStop(1, 'rgba(99,102,241,0.06)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, map.width, map.height);

          // Sites
          const drawSite = (site, color) => {
            ctx.save();
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.18;
            ctx.fillRect(site.x, site.y, site.w, site.h);
            ctx.lineWidth = 4; ctx.globalAlpha = 0.8; ctx.strokeStyle = color;
            ctx.strokeRect(site.x + 6, site.y + 6, site.w - 12, site.h - 12);
            ctx.restore();
          };
          drawSite(map.sites.A, 'rgba(239,68,68,0.45)');
          drawSite(map.sites.B, 'rgba(96,165,250,0.45)');

          // Walls
          for (const w of map.walls) {
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 2;
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeRect(w.x + 0.5, w.y + 0.5, w.w, w.h);
          }

          ctx.restore();
        }

        function drawPlayers() {
          ctx.save();
          ctx.translate(-game.camera.x, -game.camera.y);
          for (const p of game.players) {
            if (!p.alive) continue;
            const color = p.team === TEAM.CT ? '#60a5fa' : '#ef4444';
            // body
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, TAU); ctx.closePath();
            const grd = ctx.createRadialGradient(p.x - 6, p.y - 6, 6, p.x, p.y, p.r);
            grd.addColorStop(0, mixColor('#ffffff', color, 0.1));
            grd.addColorStop(1, mixColor('#0b0f14', color, 0.6));
            ctx.fillStyle = grd; ctx.fill();

            // direction
            const dirX = Math.cos(p.aim), dirY = Math.sin(p.aim);
            ctx.strokeStyle = mixColor(color, '#ffffff', 0.4);
            ctx.lineWidth = 4; ctx.beginPath();
            ctx.moveTo(p.x + dirX * 6, p.y + dirY * 6);
            ctx.lineTo(p.x + dirX * (p.r + 14), p.y + dirY * (p.r + 14));
            ctx.stroke();

            // health ring
            const hp = clamp(p.health / 100, 0, 1);
            ctx.lineWidth = 3; ctx.strokeStyle = mixColor('#ef4444', '#34d399', hp);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r + 6, -Math.PI / 2, -Math.PI / 2 + TAU * hp); ctx.stroke();
          }

          // Bomb
          if (!game.bomb.planted && !game.carrier && (game.bomb.x || game.bomb.y)) {
            ctx.fillStyle = 'rgba(250,204,21,0.9)';
            ctx.beginPath(); ctx.arc(game.bomb.x, game.bomb.y, 10, 0, TAU); ctx.fill();
          }
          if (game.bomb.planted) {
            ctx.fillStyle = 'rgba(250,204,21,0.9)';
            ctx.beginPath(); ctx.arc(game.bomb.x, game.bomb.y, 10, 0, TAU); ctx.fill();
            // pulsing ring
            const pulse = (Math.sin(now() * 0.01) + 1) * 0.5;
            ctx.strokeStyle = 'rgba(250,204,21,' + (0.25 + 0.35 * pulse) + ')'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(game.bomb.x, game.bomb.y, 20 + 6 * pulse, 0, TAU); ctx.stroke();
          }

          ctx.restore();
        }

        function drawShots() {
          ctx.save(); ctx.translate(-game.camera.x, -game.camera.y);
          for (const s of game.shots) {
            const g = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
            g.addColorStop(0, 'rgba(255,255,255,' + (0.35 * s.alpha) + ')');
            g.addColorStop(1, 'rgba(103,232,249,' + (0.85 * s.alpha) + ')');
            ctx.strokeStyle = g; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2, s.y2); ctx.stroke();
          }
          ctx.restore();
        }

        function drawHUD() {
          // Timer & state
          const t = Math.max(0, Math.floor(game.timeLeftMs / 1000));
          const m = Math.floor(t / 60).toString().padStart(2, '0');
          const s = (t % 60).toString().padStart(2, '0');
          ui.timer.textContent = `${m}:${s}`;
          ui.round.textContent = game.round === 'buy' ? 'Buy Phase' : game.round === 'live' ? 'Live' : game.round === 'planted' ? 'Bomb planted' : (game.winner ? `${game.winner} win` : 'End');

          const w = game.human.weapon;
          ui.weapon.textContent = w.name + (w.reloading ? ' — Reloading…' : '');
          ui.clip.textContent = w.clip;
          ui.reserve.textContent = ` / ${w.reserve}`;
        }

        function drawMinimap() {
          const mm = minimapCtx;
          mm.save();
          mm.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
          const scale = Math.min(minimapCanvas.width / map.width, minimapCanvas.height / map.height);
          const ox = (minimapCanvas.width - map.width * scale) * 0.5;
          const oy = (minimapCanvas.height - map.height * scale) * 0.5;
          mm.translate(ox, oy);
          mm.scale(scale, scale);
          // base
          mm.fillStyle = 'rgba(255,255,255,0.04)'; mm.fillRect(0, 0, map.width, map.height);
          // sites
          mm.fillStyle = 'rgba(239,68,68,0.25)'; const A = map.sites.A; mm.fillRect(A.x, A.y, A.w, A.h);
          mm.fillStyle = 'rgba(96,165,250,0.25)'; const B = map.sites.B; mm.fillRect(B.x, B.y, B.w, B.h);
          // walls
          mm.fillStyle = 'rgba(255,255,255,0.25)';
          for (const w of map.walls) mm.fillRect(w.x, w.y, w.w, w.h);
          // players
          for (const p of game.players) {
            if (!p.alive) continue;
            mm.fillStyle = p.team === TEAM.CT ? '#93c5fd' : '#fca5a5';
            mm.beginPath(); mm.arc(p.x, p.y, 8, 0, TAU); mm.fill();
          }
          // bomb
          if (game.bomb.planted || game.carrier) {
            const bx = game.bomb.planted ? game.bomb.x : (game.carrier ? game.carrier.x : 0);
            const by = game.bomb.planted ? game.bomb.y : (game.carrier ? game.carrier.y : 0);
            mm.fillStyle = '#fbbf24'; mm.beginPath(); mm.arc(bx, by, 10, 0, TAU); mm.fill();
          }
          mm.restore();
        }

        function drawInteractionUI() {
          const h = game.human;
          if (!h || !h.alive) return;
          const site = pointInRect(h.x, h.y, map.sites.A) || pointInRect(h.x, h.y, map.sites.B);
          let progress = 0; let label = '';
          if (!game.bomb.planted && game.carrier === h && site) { progress = game.bomb.plantProgress / 3000; label = 'Planting…'; }
          if (game.bomb.planted && Math.hypot(h.x - game.bomb.x, h.y - game.bomb.y) < h.r + 20) { progress = game.bomb.defuseProgress / game.defuseTime; label = 'Defusing…'; }
          if (progress > 0) {
            const size = 64; const x = canvas.width * 0.5; const y = canvas.height * 0.5;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.translate(x, y);
            ctx.strokeStyle = 'rgba(103,232,249,0.6)'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, size, -Math.PI/2, -Math.PI/2 + TAU * clamp(progress, 0, 1)); ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.font = '700 12px ui-sans-serif, system-ui, -apple-system'; ctx.textAlign = 'center'; ctx.fillText(label, 0, 4);
            ctx.restore();
          }
        }

        function render() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawBackground();
          drawShots();
          drawPlayers();
          drawInteractionUI();
          drawHUD();
          drawMinimap();
        }

        function loop() {
          const t = now();
          const dt = Math.min(40, t - game.lastUpdate); // clamp big jumps
          game.lastUpdate = t;
          if (game.state === 'live') update(dt);
          render();
          requestAnimationFrame(loop);
        }

        // ---------- UI Wiring ----------
        ui.btnStart.addEventListener('click', () => {
          Audio.ensure();
          Audio.ui.start();
          ui.menu.style.display = 'none';
          startGame();
        });
        ui.btnHow.addEventListener('click', () => {
          Audio.ui.confirm();
          alert('Controls:\nWASD move, Mouse aim, Click shoot, E interact, R reload, B buy, Tab scores, Esc pause.\n\nGoal:\nAs CT, prevent bomb plant or defuse it. As T, plant and defend the bomb.');
        });

        function updateScoreboard() {
          ui.scoreRows.innerHTML = '';
          const rows = [...game.players].sort((a, b) => b.score - a.score);
          for (const p of rows) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${p.name}${p === game.human ? ' (You)' : ''}</td>
              <td><span class="pill ${p.team === TEAM.CT ? 'ct' : 't'}">${p.team}</span></td>
              <td>${p.kills}</td>
              <td>${p.deaths}</td>
              <td>${p.score}</td>
            `;
            ui.scoreRows.appendChild(tr);
          }
        }

        window.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'tab') { ui.scoreboard.classList.add('show'); updateScoreboard(); }
          if (e.key.toLowerCase() === 'escape') { togglePause(); }
        });
        window.addEventListener('keyup', (e) => { if (e.key.toLowerCase() === 'tab') ui.scoreboard.classList.remove('show'); });

        function togglePause() {
          if (game.state !== 'live') return;
          game.state = 'paused';
          ui.menu.style.display = 'grid';
        }

        function startGame() {
          initPlayers();
          game.state = 'live';
          game.lastUpdate = now();
          loop();
        }

        // ---------- Buy Menu (lightweight) ----------
        window.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'b') {
            if (game.round === 'buy') {
              const choices = ['Pistol', 'Rifle', 'SMG'];
              const pick = prompt('Buy (type): Pistol / Rifle / SMG', 'Rifle');
              const p = game.human;
              if (!p) return;
              switch ((pick || '').toLowerCase()) {
                case 'rifle': p.weapon = Weapons.RIFLE(); break;
                case 'smg': p.weapon = Weapons.SMG(); break;
                default: p.weapon = Weapons.PISTOL(); break;
              }
              Audio.ui.confirm();
            } else {
              Audio.ui.warn();
              showBanner('Buy only in Buy Phase');
            }
          }
        });

        // ---------- Start in Menu ----------
        resize(); resizeMinimap();
        render();
      })();
    </script>
  </body>
  </html>


